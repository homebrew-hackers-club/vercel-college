---
title: cacheComponents ‚Äî Deep Dive Developer Guide
description: Learn how to use cacheComponents
banner: assets/cache-banner.png
---


## üîç What it is

cacheComponents is a new configuration flag introduced in Next.js 16 that changes how data fetching, caching, and pre-rendering behave inside the App Router.

In simple terms:

With `cacheComponents` enabled, pages are dynamic by default. Next.js can still pre-render a static shell and stream dynamic parts with Suspense; you opt into caching explicitly with `use cache` and related APIs where it helps. See the official guide: [Next.js Cache Components](https://nextjs.org/docs/app/getting-started/cache-components).

<Woz
title='Quick Check'
description='Do you understand the core concept?'
prompt='Explain in your own words what cacheComponents does and how it changes Next.js default behavior.'
/>

## ‚öôÔ∏è Configuration

To enable it, add the following to your `next.config.ts` (or `.js`):

```typescript
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
	cacheComponents: true,
};

export default nextConfig;
```

With Cache Components, pages are dynamic by default; opt into caching with `use cache` and `cacheLife` where appropriate ([docs](https://nextjs.org/docs/app/getting-started/cache-components)).

## üîÅ Effect on route segment config

When `cacheComponents` is enabled, several route segment options change behavior. Migrate as follows ([docs](https://nextjs.org/docs/app/getting-started/cache-components)):

- **dynamic = "force-dynamic"**: Not needed. Pages are dynamic by default.

```tsx
// Before
export const dynamic = 'force-dynamic'

export default function Page() {
  return <div>...</div>
}
```

```tsx
// After (remove it)
export default function Page() {
  return <div>...</div>
}
```

- **dynamic = "force-static"**: Replace with `use cache` in each layout/page for that route.

```tsx
// Before
export const dynamic = 'force-static'

export default async function Page() {
  const data = await fetch('https://api.example.com/data')
  return <div>...</div>
}
```

```tsx
// After
import { cacheLife } from 'next/cache'

export default async function Page() {
  'use cache'
  cacheLife('minutes')
  const data = await fetch('https://api.example.com/data')
  return <div>...</div>
}
```

- **revalidate**: Replace with `cacheLife` inside the cached scope.

```tsx
// Before
export const revalidate = 3600

export default function Page() {
  return <div>...</div>
}
```

```tsx
// After
import { cacheLife } from 'next/cache'

export default function Page() {
  'use cache'
  cacheLife('hours')
  return <div>...</div>
}
```

- **fetchCache**: Not needed. Inside a `use cache` scope, server I/O and `fetch` are cached according to the cache boundary.

## üí° Why it exists

Before cacheComponents, Next.js aggressively cached and pre-rendered most data at build time or request time depending on fetch caching options.
That worked well for static sites, but for dynamic, real-time applications (dashboards, AI apps, internal tools), this default often caused confusion and stale data issues.

So cacheComponents flips the default behavior:

**Without it:** Components are cached unless you disable it.

**With it:** Components are not cached unless you explicitly enable caching.

It's a major philosophical shift ‚Äî giving developers full control over when and how caching happens.

<Woz
title='Philosophy Check'
description='Understanding the paradigm shift'
prompt='Why do you think this "philosophical shift" matters for different types of applications? Compare static sites vs dynamic apps.'
/>

## üß© How it works conceptually

Cache Components implements Partial Prerendering (PPR) and introduces explicit cache boundaries with the `use cache` directive. The static shell can be pre-rendered while dynamic parts stream within Suspense boundaries ([docs](https://nextjs.org/docs/app/getting-started/cache-components)).

## üß± Behavior overview

Here's what changes in the lifecycle when `cacheComponents: true`:

### 1. Data fetching defaults to dynamic

All `fetch()` calls and Server Component data requests are considered dynamic unless wrapped in a cache directive.

**Example:**

```javascript
// This will re-fetch on every request
const res = await fetch('https://api.example.com/data');
const data = await res.json();
```

### 2. Caching must be explicit

If you want data to persist across requests, you must wrap it with `use cache`:

```javascript
'use cache';

export async function getData() {
	const res = await fetch('https://api.example.com/data');
	return res.json();
}
```

Now, `getData()` will be cached according to your app's cache policy.

### 3. Component trees are dynamically rendered

Components that fetch data are executed on every request.
This ensures data freshness but can increase TTFB (time-to-first-byte) if your APIs are slow.

## üß© Related APIs

cacheComponents works hand-in-hand with several other caching primitives:

| API / Directive | Purpose |
|-----------------|---------|
| `use cache` | Marks a component, function, or page as cacheable. |
| `cacheLife()` | Defines the lifespan (TTL) of cached data. |
| `cacheTag()` | Tags cached data for selective revalidation. |
| `revalidateTag()` | Triggers cache invalidation by tag. |
| `updateTag()` | Marks a tag as updated to invalidate cached entries. |
| `revalidatePath()` | Revalidates a specific route's cache entries. |

With `cacheComponents: true`, these APIs are no longer optional ‚Äî they become core primitives for controlling data persistence.

## ‚öñÔ∏è Tradeoffs

### ‚úÖ Pros

- **Always fresh data:** no stale or outdated pre-renders.
- **Predictable behavior:** runtime fetching feels more "server-like."
- **Fine-grained control:** use `use cache` and `cacheLife()` for explicit caching.
- **Ideal for real-time or authenticated apps.**

### ‚ùå Cons

- **Increased latency:** runtime fetching means slower TTFB if network-bound.
- **Higher server cost:** more frequent data fetching and computation.
- **Requires explicit caching setup:** you must consciously manage cache boundaries.

## üöÄ When to use it

Use cacheComponents when your app fits one or more of these profiles:

| Use Case | Why it helps |
|----------|--------------|
| Dashboards / Admin Panels | Always show live data; avoid stale API responses. |
| AI Applications | Model responses or content updates frequently. |
| Authenticated Apps | Avoid leaking cached content between users. |
| Internal Tools | Prioritize freshness over speed. |
| Complex real-time systems | Integrate with sockets, streams, or live APIs. |
## üß† Example Scenarios

### Without cacheComponents (default)

```typescript
// dashboard/page.tsx
export default async function Dashboard() {
	const res = await fetch('/api/stats'); // might be cached
	const data = await res.json();

	return <div>Views: {data.views}</div>;
}
```

‚úÖ **Fast.**  
‚ùå **Might show stale numbers.**

### With cacheComponents: true

```typescript
// dashboard/page.tsx
export default async function Dashboard() {
	const res = await fetch('/api/stats'); // dynamic by default
	const data = await res.json();

	return <div>Views: {data.views}</div>;
}
```

‚úÖ **Always fresh.**  
‚ùå **Slower unless wrapped with use cache.**

### If you later decide part of your data should be cached:

```typescript
'use cache';

export async function getStats() {
	const res = await fetch('/api/stats');
	return res.json();
}
```

<Woz
title='Scenario Analysis'
description='Understanding the practical implications'
prompt='Walk me through a real-world scenario where you would choose cacheComponents: true vs the default behavior. What would be your decision criteria?'
/>

## üß¨ How it interacts with ISR & PPR

ISR still works ‚Äî opt into caching with `use cache` and set duration with `cacheLife`. Cache Components implements PPR: the static shell can be pre-rendered while dynamic parts stream via Suspense. Use Suspense boundaries to control where streaming occurs. With Cache Components, caching and regeneration are opt-in at the function/component level ([docs](https://nextjs.org/docs/app/getting-started/cache-components)).

## üß© Debugging & Observability

To verify how components are being cached:

- Run your app in development mode (`pnpm dev` or `npm run dev`).
- Log or inspect requests with `console.log('cache hit/miss')`.
- Observe server logs for "rendered dynamically" messages.

## üó∫Ô∏è Migration Guide

If you're upgrading to Next.js 16:

1. **Start by enabling `cacheComponents: true` in staging only.**
2. **Identify where stale data matters** ‚Äî those are safe to leave dynamic.
3. **Gradually wrap stable data fetches in `use cache`.**
4. **Define cache lifetimes using `cacheLife()`** (e.g., 60 seconds for analytics).
5. **Add `cacheTag()` if you want fine-grained revalidation.**

## üß© Summary Table

| Feature | Default (before) | With cacheComponents |
|---------|------------------|----------------------|
| Data fetching | Static by default | Dynamic by default |
| Caching | Implicit | Explicit |
| Freshness | May be stale | Always fresh |
| Performance | Faster | Depends on runtime load |
| Use case | Static sites, blogs | Dynamic apps, dashboards |

## üß≠ Quick Mental Model

| You want | Use |
|----------|-----|
| Always live data | `cacheComponents: true` |
| Cached data by default | Default (no flag) |
| Mix of both | Enable cacheComponents and mark selected parts with `use cache` |

## üìù TL;DR

| Concept | Summary |
|---------|---------|
| cacheComponents | Makes components dynamic by default |
| `use cache` | Opt-in caching for selective parts |
| Benefits | Fresh data, better control |
| Risks | More runtime cost, slower responses |
| Use when | Building dynamic, data-driven apps |

<Woz
title='Final Reflection'
description='Putting it all together'
prompt='Based on everything you learned about cacheComponents, how would you explain this to a colleague who is new to Next.js 16? What would be the key points you would emphasize?'
/>